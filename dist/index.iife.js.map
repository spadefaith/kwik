{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/rand.ts", "../src/utils/loop.ts", "../src/services/event-bus.ts", "../src/consts/component-lifecycle.ts", "../src/components-base.ts", "../src/utils/async.ts", "../src/utils/el.ts", "../src/component-custom.ts", "../src/services/signal.ts", "../src/utils/data-wrapper.ts", "../src/component.ts", "../src/blueprint.ts", "../src/utils/append.ts"],
  "sourcesContent": ["import Component from \"./component\";\nimport Signal from \"./services/signal\";\nimport Blueprint from \"./blueprint\";\nimport render from \"./utils/append\";\nimport EventBus from \"./services/event-bus\";\nexport { render, Component, Blueprint, Signal, EventBus };\n", "/**\n * Generates an initial unique identifier by creating a UUID, removing dashes,\n * and taking the first 5 characters of the resulting string.\n *\n * @remarks\n * This identifier is intended to be used as a short, unique string for various purposes\n * within the application. The use of `crypto.randomUUID()` ensures that the generated\n * ID is highly unlikely to collide with other IDs.\n *\n * @example\n * ```typescript\n * let initialId = crypto.randomUUID().replaceAll(\"-\", \"\").substring(0, 5);\n * console.log(initialId); // Example output: 'a1b2c'\n * ```\n */\nlet initialId = null;\nlet idx = 0;\n\nexport const generateId = () => {\n  if (!initialId) {\n    if (typeof window == \"undefined\" || !window?.crypto?.randomUUID) {\n      initialId = Math.random().toString(36).substring(2, 7);\n    } else {\n      initialId = window.crypto\n        .randomUUID()\n        .replaceAll(\"-\", \"\")\n        .substring(0, 5);\n    }\n  }\n  return `x${initialId}${idx++}x`;\n};\n", "/**\n * Iterates over elements of an array, object, or map and invokes a callback for each element.\n *\n * @param array - The collection to iterate over. Can be an array, object, or map.\n * @param callback - The function to invoke for each element. It receives two arguments: the value and the key/index.\n */\nexport const loop = (array, callback) => {\n  if (!array) return;\n\n  switch (array.constructor.name) {\n    case \"Array\": {\n      for (let i = 0; i < array.length; i++) {\n        callback(array[i], i);\n      }\n      break;\n    }\n    case \"Object\": {\n      for (let key in array) {\n        callback(array[key], key);\n      }\n      break;\n    }\n    case \"Map\": {\n      for (let [key, value] of array.entries()) {\n        callback(value, key);\n      }\n      break;\n    }\n    default: {\n      if (array.length) {\n        for (let i = 0; i < array.length; i++) {\n          callback(array[i], i);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Asynchronously iterates over elements of an array, object, or map and invokes a callback for each element.\n *\n * @param array - The collection to iterate over. Can be an array, object, or map.\n * @param callback - The async function to invoke for each element. It receives two arguments: the value and the key/index.\n * @returns A promise that resolves when all elements have been processed.\n */\nexport const loopAsync = async (array, callback): Promise<void> => {\n  if (!array) return;\n\n  async function* asyncIterableArray(array) {\n    for (let i = 0; i < array.length; i++) {\n      yield [array[i], i];\n    }\n  }\n\n  async function* asyncIterableObject(obj) {\n    for (let key in obj) {\n      yield [obj[key], key];\n    }\n  }\n\n  async function* asyncIterableMap(map) {\n    for (let [key, value] of map.entries()) {\n      yield [value, key];\n    }\n  }\n\n  const ctcConstructorName = array.constructor.name;\n\n  for await (let [value, key] of ctcConstructorName == \"Array\"\n    ? asyncIterableArray(array)\n    : ctcConstructorName == \"Object\"\n    ? asyncIterableObject(array)\n    : ctcConstructorName == \"Map\"\n    ? asyncIterableMap(array)\n    : asyncIterableArray(array)) {\n    await callback(value, key);\n  }\n};\n", "import { loop } from \"../utils/loop\";\n\nexport default class EventBus {\n  subscriber: any;\n  constructor() {\n    this.subscriber = {};\n  }\n\n  on(event, callback) {\n    if (!this.subscriber[event]) {\n      this.subscriber[event] = [];\n    }\n\n    this.subscriber[event].push(callback);\n  }\n\n  broadcast(event, data) {\n    const listeners = this.subscriber[event] || [];\n    let index = 0;\n    const recur = (listeners) => {\n      if (listeners.length > index) {\n        let callback = listeners[index];\n        callback(data, () => {\n          index++;\n          recur(listeners);\n        });\n      }\n      if (listeners.length - 1 == index) {\n      }\n    };\n\n    recur(listeners);\n  }\n\n  clean(event?) {\n    if (event) {\n      this.subscriber[event] && (this.subscriber[event] = []);\n    } else {\n      loop(this.subscriber, (value, key) => {\n        this.subscriber[key] = [];\n      });\n    }\n  }\n  toString() {\n    return \"\";\n  }\n}\n", "export const BEFORE_RENDERED = \"before_rendered\";\nexport const RENDERED = \"rendered\";\nexport const DESTROY = \"destroy\";\nexport const CHANGE = \"change\";\nexport const ADOPTED = \"adopted\";\nexport const COMPONENT_LIFECYCLE = {\n  BEFORE_RENDERED,\n  RENDERED,\n  DESTROY,\n  CHANGE,\n  ADOPTED,\n};\n", "import { generateId } from \"./utils/rand\";\nimport EventBus from \"./services/event-bus\";\nimport Signal from \"./services/signal\";\nimport { loop } from \"./utils/loop\";\nimport { COMPONENT_LIFECYCLE } from \"./consts/component-lifecycle\";\nimport { ComponentOptionType } from \"./types\";\nexport type AttributesItemType = {\n  [key: string]: {\n    signal_id: string;\n    name: string;\n    callbacks?: (a: any) => any;\n  };\n};\n\nexport type SignalItemType = {\n  [key: string]: {\n    signal: Signal;\n    callbacks?: ((a: any) => any)[];\n  };\n};\n\nclass _GlobalEventBus {\n  subscriber: any;\n  constructor() {\n    this.subscriber = {};\n  }\n  on(component: string, event: string, callback: (props?: any) => any) {\n    if (!this.subscriber[component]) {\n      this.subscriber[component] = new EventBus();\n    }\n    this.subscriber[component].on(event, callback);\n  }\n  broadcast(component, event, data) {\n    this.subscriber[component].broadcast(event, data);\n  }\n\n  clean(name?) {\n    if (name) {\n      const g = this.subscriber[name];\n      if (g) {\n        g.clean();\n      }\n    } else {\n      Object.keys(this.subscriber).forEach((key) => {\n        this.subscriber[key].clean();\n      });\n    }\n  }\n}\n\n/**\n * singleton instance of GlobalEventBus\n */\nconst GlobalEventBus = new _GlobalEventBus();\n\nconst GlobalHandlers = {};\n\nclass ComponentBase {\n  name: string;\n  id: string;\n  attributes: object;\n  template: (props?: any) => string;\n  callback: any;\n  signals: SignalItemType;\n  styles: any;\n  eventsStore: any;\n  lifecycle: EventBus;\n  options: ComponentOptionType;\n  refs: any;\n  attributeChangePayload: object;\n  globalEventBus: _GlobalEventBus;\n  globalHandlers: object;\n  destroyTimeout: number;\n\n  /**\n   * Creates an instance of the component with the specified callback and options.\n   *\n   * @param callback - The callback function to be executed.\n   * @param options - An optional object containing additional configuration options.\n   *\n   * @property {any} callback - The callback function provided during instantiation.\n   * @property {string} id - A unique identifier generated for the instance.\n   * @property {string} name - A name generated for the instance, prefixed with 'x-'.\n   * @property {object} options - The configuration options merged with a default extension of HTMLElement.\n   * @property {object} attributes - An object to store attributes.\n   * @property {object} template - An object to store template information.\n   * @property {object} signals - An object to store signals.\n   * @property {object} styles - An object to store styles.\n   * @property {Array} eventsStore - An array to store events.\n   * @property {object} refs - An object to store references.\n   * @property {EventBus} lifecycle - An instance of EventBus to manage lifecycle events.\n   */\n  constructor(callback: any, options = {} as any) {\n    this.callback = callback;\n    this.id = generateId();\n    this.name = `x-${this.id}`;\n    this.options = { extension: HTMLElement, ...options };\n\n    this.attributes = {};\n    this.signals = {};\n    this.styles = {};\n    this.eventsStore = [];\n    this.refs = {};\n    this.attributeChangePayload = {};\n    this.lifecycle = new EventBus();\n    this.globalEventBus = GlobalEventBus;\n    this.globalHandlers = GlobalHandlers;\n  }\n  /**\n   * Initializes the lifecycle events for the component.\n   *\n   * This method sets up various lifecycle event listeners for the component,\n   * including handling changes, rendering, and destruction of the component.\n   *\n   * - On `COMPONENT_LIFECYCLE.CHANGE`: Updates signal values and triggers attribute callbacks.\n   * - On `COMPONENT_LIFECYCLE.RENDERED`: Executes signal callbacks, sets up event listeners,\n   *   invokes reference callbacks, and applies styles.\n   * - On `COMPONENT_LIFECYCLE.DESTROY`: Cleans up attributes, template, signals, styles, events,\n   *   references, and lifecycle listeners.\n   *\n   * @private\n   */\n  _initLifecycle() {\n    this.lifecycle.on(\n      COMPONENT_LIFECYCLE.CHANGE,\n      ({ name, oldValue, newValue }, next) => {\n        const attrConf = this.attributes[name] || {};\n        const signalId = attrConf.signal_id;\n        if (!signalId) return;\n        const { signal } = this.signals[signalId] || {};\n        if (signal) {\n          signal.value = newValue;\n        }\n\n        if (oldValue != newValue) {\n          /**\n           * stores the updated attributes temporarily\n           * later on this value will be used to update\n           * the signal\n           */\n          this.attributeChangePayload[name] = {\n            oldValue,\n            newValue,\n            signal_id: signalId,\n          };\n        }\n\n        next();\n      }\n    );\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.RENDERED, (el, next) => {\n      clearTimeout(this.destroyTimeout);\n      next();\n    });\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.RENDERED, (el, next) => {\n      loop(this.signals, (a) => {\n        const { signal, callbacks } = a;\n\n        const find = Object.keys(this.attributeChangePayload).find((key) => {\n          return this.attributeChangePayload[key].signal_id == signal.id;\n        });\n        let value = signal.value;\n        if (find) {\n          /**\n           * when the signal is present in this.attributeChangePayload\n           * the new value will be used as value for signal;\n           * then delete that value;\n           */\n          value = this.attributeChangePayload[find].newValue;\n          delete this.attributeChangePayload[find];\n        }\n\n        if (callbacks.length) {\n          loop(callbacks, (callback) => {\n            callback && callback(value);\n          });\n        } else {\n          if (find) {\n            signal.value = value;\n          }\n        }\n      });\n\n      next();\n    });\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.RENDERED, (el, next) => {\n      setTimeout(() => {\n        loop(this.eventsStore, (event) => {\n          const { type, id, handler } = event;\n          const target: HTMLElement = el.querySelector(\n            `[data-event=${type}-${id}]`\n          );\n\n          if (target) {\n            target.addEventListener(type, (e) => {\n              handler(e);\n            });\n          }\n        });\n      });\n\n      next();\n    });\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.RENDERED, (el, next) => {\n      loop(this.refs, (ref, key) => {\n        if (!ref.is_rendered) {\n          ref.callback(el);\n        }\n      });\n      next();\n    });\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.RENDERED, (el, next) => {\n      loop(this.styles, (styles, id) => {\n        const target: HTMLElement = document.querySelector(\n          `[data-style=${id}]`\n        );\n        if (!target) return;\n        loop(styles, (value, key) => {\n          target.style[key] = value;\n        });\n      });\n\n      next();\n    });\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.DESTROY, (el, next) => {\n      this.signals = {};\n      this.styles = {};\n      this.eventsStore = [];\n\n      /**\n       * this will clear the remaining storage\n       * at 2 seconds after the component is destroyed\n       */\n      clearTimeout(this.destroyTimeout);\n      this.destroyTimeout = setTimeout(() => {\n        this.attributes = {};\n        this.lifecycle.clean();\n        this.refs = {};\n        if (this.globalHandlers[this.name]) {\n          this.globalHandlers[this.name] = {};\n        }\n\n        this.globalEventBus.clean(this.name);\n      }, 2000);\n\n      next();\n    });\n  }\n\n  /**\n   * Registers a signal to this.signals.\n   * When the component is rendered this.signals will be looped\n   * to update the value, the value commonly came from the component props/attributes\n   *\n   * @param signal - The signal object to register.\n   * @param callback - Optional. The callback function to be executed when the signal is triggered.\n   */\n  _registerSignal(signal, callback?) {\n    if (!this.signals[signal.id]) {\n      this.signals[signal.id] = { signal, callbacks: [] };\n    }\n\n    callback && this.signals[signal.id].callbacks.push(callback);\n  }\n\n  /**\n   * Sets the lifecycle value for the component.\n   *\n   * @param value - The new lifecycle value to be set.\n   */\n  _setLifecycle(value) {\n    this.lifecycle = value;\n  }\n}\n\nexport default ComponentBase;\n", "/**\n * Converts a callback-based function to a Promise-based one.\n *\n * @param callback - The function to be promisified. Must be a function.\n * @param args - The arguments to pass to the callback function.\n * @returns A Promise that resolves with the result of the callback function or rejects with an error.\n * @throws Will throw an error if the first argument is not a function.\n */\nexport const promisify = (callback, ...args) => {\n  return new Promise((resolve, reject) => {\n    try {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"First argument must be a function\");\n      }\n      const isAsync = callback.constructor.name === \"AsyncFunction\";\n      if (isAsync) {\n        callback\n          .apply(this, args)\n          .then((resp) => resolve(resp))\n          .catch((err) => reject(err));\n      } else {\n        const resp = callback.apply(this, args);\n        resolve(resp);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n", "/**\n * Retrieves all comment nodes from a given DOM node. Optionally filters comments by a target value.\n *\n * @param {Node} node - The DOM node to search for comment nodes.\n * @param {string} [target] - Optional. The target comment value to filter by.\n * @returns {Comment[]} An array of comment nodes. If a target is provided, only comments matching the target value are returned.\n */\nexport const getComments = (node, target?) => {\n  const xPath = \"//comment()\",\n    result = [];\n\n  let query = document.evaluate(\n    xPath,\n    node,\n    null,\n    XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n\n  for (let i = 0, length = query.snapshotLength; i < length; ++i) {\n    const item: any = query.snapshotItem(i);\n    if (target) {\n      if (target == item.nodeValue) {\n        result.push(item);\n      }\n    } else {\n      result.push(item);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts a string of HTML into a Document's body element.\n *\n * @param str - The HTML string to be converted.\n * @returns The body element of the parsed HTML document.\n */\nexport const stringToHTML = (str) => {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(str, \"text/html\");\n\n  return doc.body;\n};\n", "import ComponentBase from \"./components-base\";\nimport { COMPONENT_LIFECYCLE } from \"./consts/component-lifecycle\";\nimport { promisify } from \"./utils/async\";\nimport { stringToHTML } from \"./utils/el\";\nimport { loopAsync } from \"./utils/loop\";\n\nclass ComponentCustom extends ComponentBase {\n  replaced: any;\n  timeout: number;\n  renderCount: number;\n  webComponentInstance: WeakMap<any, any>;\n  constructor(callback, options = {} as any) {\n    super(callback, options);\n    this.callback = callback;\n    this.replaced = {};\n    this.renderCount = 0;\n\n    this.webComponentInstance = new WeakMap();\n  }\n\n  /**\n   * Creates a custom HTML element based on the provided configuration.\n   *\n   * This method checks if a custom element with the specified name already exists.\n   * If it does, it returns `true`. Otherwise, it defines a new custom element\n   * using the provided attributes, options, and lifecycle callbacks.\n   *\n   * @returns {boolean} - Returns `true` if the custom element is successfully created or already exists.\n   */\n  createCustomElement() {\n    if (customElements.get(this.name)) {\n      return true;\n    }\n\n    const self = this;\n\n    const CustomElementDefinition: any = (ext) =>\n      class extends ext {\n        static observedAttributes = [\n          ...[...new Set(Object.keys(self.attributes))],\n          \"key\",\n        ];\n        constructor() {\n          super();\n          this._container();\n        }\n\n        async connectedCallback() {\n          // await self._connectedCallback(this, this._container());\n\n          /**\n           * A component is connectedCallback is called in the following scenario\n           * 1. render()\n           * 2. regular render\n           * 3. replacedWith - it refers to when the component is inserted via slot\n           *\n           * the timeout makes sure that only the last call of the connectedCallback\n           * will call the component callback.\n           *\n           */\n\n          clearTimeout(self.timeout);\n          await new Promise(async (res: any, rej) => {\n            self.timeout = setTimeout(() => {\n              self.webComponentInstance.set(this, this);\n              self\n                ._connectedCallback(this, this._container())\n                .then(res())\n                .catch((err) => rej(err));\n            }, 50);\n          });\n        }\n        disconnectedCallback() {\n          self._disconnectedCallback(this);\n        }\n        adoptedCallback() {\n          self.webComponentInstance.set(this, this);\n          self._adoptedCallback(this);\n        }\n        attributeChangedCallback(name, oldValue, newValue) {\n          self._attributeChangedCallback(name, oldValue, newValue);\n        }\n\n        _container() {\n          if ([\"open\", \"closed\"].includes(self.options.type)) {\n            this.attachShadow({ mode: self.options.type });\n            return this.shadowRoot;\n          } else {\n            return this;\n          }\n        }\n      };\n\n    customElements.define(\n      this.name,\n      CustomElementDefinition(self.options.extension)\n    );\n\n    return true;\n  }\n  /**\n   * Handles the adopted callback for the custom component.\n   *\n   * This method is called when the custom element is adopted into a new document.\n   * It broadcasts the `ADOPTED` lifecycle event with the provided element.\n   *\n   * @param self - The custom element instance that is being adopted.\n   */\n  _adoptedCallback(self) {\n    this.lifecycle.broadcast(COMPONENT_LIFECYCLE.ADOPTED, self);\n  }\n  /**\n   * Handles the disconnection of the component by broadcasting a destroy event.\n   *\n   * @param self - The instance of the component that is being disconnected.\n   */\n  _disconnectedCallback(self) {\n    this.webComponentInstance.has(self) &&\n      this.webComponentInstance.delete(self);\n\n    this.lifecycle.broadcast(COMPONENT_LIFECYCLE.DESTROY, null);\n  }\n  /**\n   * Callback method that is invoked when an attribute of the custom element is added, removed, or changed.\n   *\n   * @param name - The name of the attribute that was changed.\n   * @param oldValue - The previous value of the attribute before the change.\n   * @param newValue - The new value of the attribute after the change.\n   */\n  _attributeChangedCallback(name, oldValue, newValue) {\n    this.lifecycle.broadcast(COMPONENT_LIFECYCLE.CHANGE, {\n      name,\n      oldValue,\n      newValue,\n    });\n  }\n  /**\n   * Handles the connected callback lifecycle event for the custom component.\n   *\n   * @param self - The instance of the custom component.\n   * @param container - The container element where the component's content will be appended.\n   * @returns A promise that resolves once the component has been fully rendered and all necessary slots have been processed.\n   *\n   * @remarks\n   * This method performs the following tasks:\n   * 1. Replaces the slot content with the component's template.\n   * 2. Removes any unused slots from the template.\n   * 3. Appends all child nodes of the component and its template to the container.\n   * 4. Broadcasts the `COMPONENT_LIFECYCLE.RENDERED` event once rendering is complete.\n   */\n  async _connectedCallback(self, container) {\n    const template = this._templateToHtml();\n\n    if (!template) {\n      return;\n    }\n    // console.trace();\n\n    await this._replaceSlot(self, template);\n    await this._removeUnusedSlotsInTemplate(template);\n\n    await loopAsync(self.childNodes, async (child) => {\n      {\n        return container.appendChild(child);\n      }\n    });\n    await loopAsync(template.childNodes, async (child) => {\n      return container.appendChild(child);\n    });\n\n    await this.lifecycle.broadcast(COMPONENT_LIFECYCLE.RENDERED, self);\n\n    // console.log(123, this.callback, self.outerHTML);\n    // console.log(123, this.callback, \"_connectedCallback\");\n  }\n\n  /**\n   * Asynchronously removes all named slots from the given target element's template.\n   *\n   * @param target - The target element containing the template with slots to be removed.\n   * @returns A promise that resolves when all named slots have been removed.\n   */\n  async _removeUnusedSlotsInTemplate(target) {\n    //removing remaining slot of the template;\n    const targetSlots = target.querySelectorAll(\"slot[name]\");\n    await loopAsync(targetSlots, async (slot, i) => slot.remove());\n  }\n\n  /**\n   * Replaces the slots in the target element with the corresponding slots from the source element.\n   *\n   * @param src - The source element containing the slots to be copied.\n   * @param target - The target element where the slots will be replaced.\n   *\n   * This method performs the following steps:\n   * 1. Selects all elements with a \"slot\" attribute from the source element.\n   * 2. Iterates over each slot and performs the following actions:\n   *    - Retrieves the slot name and removes the \"slot\" attribute from the source slot.\n   *    - Finds the corresponding slot in the target element.\n   *    - If a corresponding slot is found in the target:\n   *      - Copies all attributes (except \"name\") from the target slot to the source slot.\n   *      - Replaces the target slot with the cloned source slot.\n   *      - Removes the original source slot.\n   *    - If no corresponding slot is found in the target:\n   *      - Removes the source slot.\n   *\n   * This method uses asynchronous operations to handle the slot replacement and attribute copying.\n   */\n  async _replaceSlot(src, target) {\n    const slots = src.querySelectorAll(\"[slot]\");\n\n    await loopAsync(slots, async (slot, i) => {\n      const slotName = slot.getAttribute(\"slot\");\n      slot.removeAttribute(\"slot\");\n      //this refers to slot from the template that will be replaced by slot from the child of this component\n      const targetSlot = target.querySelector(`slot[name=${slotName}]`);\n      if (targetSlot) {\n        //copying the attributes from the template slot to the slot from the child by looping through the attributes\n        const attributes = targetSlot.attributes;\n        await loopAsync(attributes, async (attr) => {\n          if (attr.name == \"name\") return;\n          slot.setAttribute(attr.name, attr.value);\n        });\n        await promisify(\n          (targetSlot, slot) => {\n            this.replaced[slotName] = slot;\n            return targetSlot.replaceWith(slot.cloneNode(true));\n          },\n          targetSlot,\n          slot\n        );\n        await promisify((slot) => slot.remove(), slot);\n      } else {\n        await promisify((slot) => slot.remove(), slot);\n      }\n    });\n  }\n\n  /**\n   * Converts the template to an HTML string.\n   *\n   * If the template is a function, it will be executed and its result will be converted to HTML.\n   * Otherwise, the template itself will be returned.\n   *\n   * @returns {string} The HTML string representation of the template.\n   */\n  _templateToHtml() {\n    const templateType = typeof this.template;\n    if (templateType == \"function\") {\n      const template = this.template();\n      const converted = stringToHTML(template);\n\n      return converted;\n    } else if (templateType == \"string\") {\n      return stringToHTML(this.template);\n    }\n  }\n}\n\nexport default ComponentCustom;\n", "import { generateId } from \"../utils/rand\";\nimport EventBus from \"./event-bus\";\n\nexport default class Signal {\n  id: string;\n  _value: any;\n  subscribers: any[];\n  pubsub: EventBus;\n  constructor(initialValue) {\n    this.id = generateId();\n    this._value = initialValue;\n    this.pubsub = new EventBus();\n  }\n  _notify() {\n    this.pubsub.broadcast(\"signal\", this._value);\n  }\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    const test = this._checkEquality(this._value, v);\n    if (test) {\n      return;\n    }\n    this._value = v;\n    this._notify();\n  }\n  subscribe(subscriber) {\n    this.pubsub.on(\"signal\", (data, next) => {\n      subscriber(data);\n      next();\n    });\n  }\n\n  toString() {\n    try {\n      return this._value?.toString();\n    } catch (e) {\n      return String(this._value);\n    }\n  }\n\n  _checkEquality(a, b) {\n    const typeA = typeof a;\n    const typeB = typeof b;\n\n    if (typeA !== typeB) return false;\n\n    if (typeA === \"number\" && typeB === \"number\") {\n      return a === b;\n    }\n\n    if (typeA === \"string\" && typeB === \"string\") {\n      return a === b;\n    }\n    if (typeA === \"boolean\" && typeB === \"boolean\") {\n      return a === b;\n    }\n\n    if (typeA === \"undefined\" && typeB === \"undefined\") {\n      return true;\n    }\n\n    if (typeA === null && typeB === null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  get isSignal() {\n    return true;\n  }\n}\n", "import { loop } from \"./loop\";\n\n/**\n * A class that wraps data and provides utility methods to interact with it.\n */\nexport default class DataWrapper {\n  /**\n   * Creates an instance of DataWrapper.\n   * @param ctx - The context or data to be wrapped.\n   */\n  constructor(public ctx) {\n    this.ctx = ctx;\n  }\n\n  /**\n   * Gets the wrapped data.\n   * @returns The wrapped data.\n   */\n  get data() {\n    return this.ctx;\n  }\n\n  /**\n   * Checks if the wrapped data is empty.\n   * @returns `true` if the data is empty, otherwise `false`.\n   */\n  get isEmpty() {\n    const type = typeof this.ctx;\n\n    if (!this.ctx) {\n      return true;\n    }\n    if (this.ctx.size !== undefined) {\n      return this.ctx.size === 0;\n    } else if (this.ctx.length !== undefined) {\n      return this.ctx.length === 0;\n    }\n\n    if (type === \"object\") {\n      return Object.keys(this.ctx).length === 0;\n    }\n\n    return true;\n  }\n\n  /**\n   * Iterates over the wrapped data and applies a callback function to each element.\n   * @param callback - The function to be called for each element. It receives the value and key as arguments.\n   * @returns A concatenated string of the results of the callback function.\n   */\n  each(callback) {\n    let str = \"\";\n    loop(this.ctx, (value, key) => {\n      str += callback(value, key);\n    });\n    return str;\n  }\n}\n", "import ComponentCustom from \"./component-custom\";\nimport ComponentBase from \"./components-base\";\nimport { COMPONENT_LIFECYCLE } from \"./consts/component-lifecycle\";\nimport EventBus from \"./services/event-bus\";\nimport Signal from \"./services/signal\";\nimport DataWrapper from \"./utils/data-wrapper\";\nimport { getComments, stringToHTML } from \"./utils/el\";\nimport { loop, loopAsync } from \"./utils/loop\";\nimport { generateId } from \"./utils/rand\";\n\nimport { ComponentOptionType } from \"./types\";\nimport { promisify } from \"./utils/async\";\n\nclass Component extends ComponentCustom {\n  constructor(callback, options: ComponentOptionType) {\n    super(callback, options);\n    this.callback = callback;\n\n    const template = this.callback({\n      node: this.node.bind(this),\n      render: this.render.bind(this),\n      attr: this.attr.bind(this),\n      events: this.events.bind(this),\n      props: this.props.bind(this),\n      style: this.style.bind(this),\n      ref: this.ref.bind(this),\n      signal: this.signal.bind(this),\n      onConnected: this.onConnected.bind(this),\n      sub: this.sub.bind(this),\n      pub: this.pub.bind(this),\n      handler: this.handler.bind(this),\n    });\n\n    this.template = template;\n    this._initLifecycle();\n    this.createCustomElement();\n  }\n\n  /**\n   * It represents the DOM Text Node, It updates the textnode when the signal value changes.\n   *\n   * @param signal - The signal to be registered and used for DOM updates.\n   * @returns A string representing an HTML comment with the signal's ID and value.\n   *\n   */\n  node(signal: Signal): string {\n    this._registerSignal(signal);\n\n    signal.subscribe((value) => {\n      const id = signal.id;\n\n      const self = document.querySelector(this.name);\n\n      if (!self) {\n        return;\n      }\n\n      const node: any[] = getComments(self, `node ${id}`);\n\n      if (!node.length) {\n        return;\n      }\n\n      loop(node, (n) => {\n        const next = n.nextSibling;\n\n        if (next.nodeType == 3) {\n          if (next.nodeValue[0] == \" \") {\n            next.nodeValue = ` ${value}`;\n          } else {\n            next.nodeValue = value.value;\n          }\n        }\n      });\n    });\n\n    // this._registerSignal(signal);\n\n    return `<!--node ${signal.id}--> ${signal}`;\n  }\n\n  /**\n   * It will render the template with the signal value.\n   *  It will replace the content if the template is a string.\n   *  It will append the content if the template is a function.\n   *  It will render the content with the renderer if provided.\n   *  It will return HTML comment with the signal ID.\n   *\n   * @param ctx\n   * @param template\n   * @param opts\n   * @returns HTML comment with the signal ID.\n   */\n  render(\n    ctx: any,\n    template: (params: DataWrapper) => string,\n    opts?: {\n      replace?: boolean;\n      renderer?: {\n        render: Function;\n      };\n    }\n  ): string {\n    if (!opts) {\n      opts = {};\n    }\n    const templateType = typeof template;\n\n    /**\n     * allow even if not a signal,\n     * if so, create a signal.\n     */\n    if (!ctx?.isSignal) {\n      ctx = new Signal(ctx);\n    }\n\n    if (opts.replace == undefined) {\n      opts.replace = true;\n    }\n\n    const callback = (value) => {\n      value = new DataWrapper(value);\n\n      const id = ctx.id;\n      const self = document.querySelector(this.name);\n\n      if (!self) {\n        return;\n      }\n\n      const node = getComments(self, `render ${id}`);\n      if (!node.length) {\n        return;\n      }\n      loop(node, (n) => {\n        let r = template(value);\n\n        if (opts.renderer) {\n          r = opts.renderer.render(r, {\n            list: value,\n          });\n        }\n\n        if (!n.isInitialized) {\n          n.isInitialized = true;\n        }\n        if (n.isInitialized) {\n          if (opts.replace) {\n            const next = n.nextSibling;\n\n            next && next.remove();\n          }\n        }\n        if (!r) {\n          return;\n        }\n        const rHtml = stringToHTML(r);\n        n.parentElement.insertBefore(rHtml.firstChild, n.nextSibling);\n      });\n    };\n\n    ctx.subscribe(callback);\n    this._registerSignal(ctx, callback);\n\n    return `<!--render ${ctx.id}-->`;\n  }\n\n  /**\n   * Updates the attribute of elements based on a signal context.\n   *  The attribute will be updated when the signal value changes.\n   *  The attribute will be updated for all elements with the specified attribute and context ID.\n   *\n   * @param attr - The attribute to be updated.\n   * @param ctx - The context object containing signal information.\n   * @returns The selector string used to identify elements with the specified attribute and context ID.\n   */\n  attr(attr, ctx) {\n    if (!ctx.isSignal) return;\n    const sel = `data-${attr}=${ctx.id}`;\n\n    let callback = (value) => {\n      setTimeout(() => {\n        const targets: NodeListOf<Element> = document.querySelectorAll(\n          `[${sel}]`\n        );\n\n        loop(targets, (target) => {\n          target.setAttribute(attr, value);\n        });\n      });\n    };\n\n    const keys = Object.keys(this.attributes);\n\n    for (let i = 0; i < keys.length; i++) {\n      const conf = this.attributes[keys[i]];\n      //\n      const { signal_id } = conf;\n      if (ctx.id == signal_id) {\n        if (!conf.callbacks) {\n          conf.callbacks = [];\n        }\n\n        conf.callbacks.push(callback);\n        // break;\n      }\n    }\n\n    // ctx.subscribe(callback);\n\n    this._registerSignal(ctx, callback);\n\n    return sel;\n  }\n\n  events(events) {\n    let str = \"\";\n\n    loop(events, (handler, key) => {\n      const id = generateId();\n      this.eventsStore.push({\n        id,\n        type: key,\n        handler,\n      });\n      str += `data-event=${key}-${id} `;\n    });\n\n    return str;\n  }\n  props(name, initialValue) {\n    const signal = new Signal(initialValue);\n\n    this.attributes[name] = { signal_id: signal.id, name };\n\n    // console.log(261, this.callback, name, signal.id, this.attributes[name]);\n\n    return signal;\n  }\n  style(obj) {\n    const id = generateId();\n    this.styles[id] = obj;\n    loopAsync(obj, async (key) => {\n      const value = obj[key];\n\n      if (!value.isSignal) return;\n      const callback = (v) => {\n        const target: HTMLElement = document.querySelector(\n          `[data-style=${id}]`\n        );\n        if (target) {\n          target.style[key] = v;\n        }\n      };\n      this._registerSignal(value, (value) => promisify(callback, value));\n\n      value.subscribe((value) => promisify(callback, value));\n    });\n    return `data-style=${id}`;\n  }\n  ref(callback?) {\n    const id = generateId();\n    if (callback) {\n      const cb = (self) => {\n        setTimeout(() => {\n          const target: HTMLElement = self.querySelector(`[data-ref=${id}]`);\n          if (target) {\n            this.refs[id].is_rendered = true;\n          }\n          callback(target);\n        });\n      };\n\n      this.refs[id] = {\n        callback: cb,\n        is_rendered: false,\n      };\n    }\n\n    const $this: any = this;\n    return {\n      get current() {\n        const self = document.querySelector($this.name);\n        if (!self) {\n          return null;\n        }\n        const target = self.querySelector(`[data-ref=${id}]`);\n\n        return target;\n      },\n      toString() {\n        return `data-ref=${id}`;\n      },\n    };\n  }\n  signal<T>(value) {\n    return new Signal(value) as T;\n  }\n  onConnected(callback) {\n    if (typeof callback !== \"function\") return;\n    const getType = (callback) => callback.constructor.name;\n    const assignDisconnect = (callback, _next) => {\n      this.lifecycle.on(COMPONENT_LIFECYCLE.DESTROY, (el, next) => {\n        switch (getType(callback)) {\n          case \"AsyncFunction\": {\n            callback(el)\n              .then(next)\n              .catch((err) => {\n                console.error(err);\n                next();\n              });\n            return;\n          }\n          case \"Function\": {\n            callback(el);\n            next();\n            return;\n          }\n          default: {\n            next();\n          }\n        }\n      });\n\n      _next();\n    };\n\n    this.lifecycle.on(COMPONENT_LIFECYCLE.RENDERED, (el, next) => {\n      switch (getType(callback)) {\n        case \"AsyncFunction\": {\n          callback(el).then((disconnectCallback) => {\n            if (typeof disconnectCallback !== \"function\") return next();\n            assignDisconnect(disconnectCallback, next);\n          });\n          return;\n        }\n        case \"Function\": {\n          const disconnectCallback = callback(el);\n\n          console.log(this.callback, getType(callback));\n\n          if (typeof disconnectCallback !== \"function\") return next();\n          assignDisconnect(disconnectCallback, next);\n          break;\n        }\n        default: {\n          next();\n        }\n      }\n    });\n  }\n  /**\n   * Subscribes to a global event bus with the specified event name and callback function.\n   *\n   * @param name - The name of the event to subscribe to.\n   * @param callback - The function to be called when the event is triggered.\n   * @returns A string representing the subscription in the format `data-sub-{name}={this.name}`.\n   */\n  sub(name, callback) {\n    this.globalEventBus.on(this.name, name, callback);\n    return `data-sub-${name}=${this.name}`;\n  }\n\n  /**\n   * Publishes an event to a specified component.\n   *\n   * @param name - The name of the event to publish.\n   * @returns A function that takes data as an argument and broadcasts the event with the provided data,\n   *          or undefined if the component or attribute is not found.\n   */\n  pub(name) {\n    const self = document.querySelector(this.name);\n    if (!self) return;\n    const srcComponent = self.getAttribute(`data-sub-${name}`);\n    if (!srcComponent) return;\n    return (data) => {\n      this.globalEventBus.broadcast(srcComponent, name, data);\n    };\n  }\n\n  /**\n   * Registers or retrieves a global handler function.\n   *\n   * @param name - The name of the handler.\n   * @param callback - An optional callback function to register as the handler.\n   *                    If not provided, the function will return the existing handler for the given name.\n   * @returns The existing handler function if `callback` is not provided, or `true` if the handler was successfully registered.\n   */\n  handler(...args) {\n    //getter\n    const ctx = args[0];\n    const ctxType = typeof ctx;\n    if (args.length == 1 && ctxType == \"string\") {\n      const name = args[0];\n      const self = document.querySelector(this.name);\n      if (!self) return;\n      const srcComponent = self.getAttribute(`data-handler-${name}`);\n      if (!srcComponent) return;\n      if (!this.globalHandlers[srcComponent]) {\n        throw new Error(`Handler is not properly set in ${srcComponent}`);\n      }\n      if (!this.globalHandlers[srcComponent][name]) {\n        throw new Error(`Handler ${name} not found in ${srcComponent}`);\n      }\n      return this.globalHandlers[srcComponent][name];\n    }\n\n    //setter\n\n    if (!this.globalHandlers[this.name]) {\n      this.globalHandlers[this.name] = {};\n    }\n\n    switch (ctxType) {\n      case \"string\": {\n        const [name, callback] = args;\n\n        this.globalHandlers[this.name][name] = callback;\n\n        return `data-handler-${name}=${this.name}`;\n      }\n      case \"object\": {\n        let str = \"\";\n        loop(ctx, (callback, name) => {\n          this.globalHandlers[this.name][name] = callback;\n\n          str += `data-handler-${name}=${this.name} `;\n        });\n\n        return str;\n      }\n    }\n\n    return \"\";\n  }\n}\n\nexport default Component;\n", "import Component from \"./component\";\nimport { ComponentOptionType } from \"./types\";\n\n/**\n * Represents a blueprint for creating a component.\n *\n * @remarks\n * This class is used to create and manage a component instance using a callback function and optional parameters.\n *\n * @example\n * ```typescript\n * const blueprint = new Blueprint((params) => {\n *   // Initialize component with params\n * }, { option1: 'value1' });\n *\n * const componentName = blueprint.build();\n * console.log(componentName);\n * ```\n *\n * @public\n */\nexport default class Blueprint {\n  callback: any;\n  current: any;\n  options: ComponentOptionType;\n  /**\n   * Creates an instance of the class.\n   *\n   * @param callback - A function that takes the parameters of the Component prototype.\n   * @param options - An optional parameter of type ComponentOptionType. Defaults to an empty object.\n   */\n  constructor(\n    callback: (params: typeof Component.prototype) => void,\n    options = {} as ComponentOptionType\n  ) {\n    this.callback = callback;\n    this.current = null;\n\n    this.options = options || ({} as any);\n  }\n\n  /**\n   * Builds a new component instance using the provided callback and options.\n   *\n   * @returns {string} The name of the newly created component.\n   */\n  build() {\n    this.current = new Component(this.callback, this.options);\n    return this.current;\n  }\n  /**\n   * Converts the current object to a string representation.\n   *\n   * @returns {string} The string representation of the current object.\n   */\n  toString() {\n    this.build();\n    return this.current.name;\n  }\n\n  /**\n   * Getter for the `close` property.\n   *\n   * @returns {string} The name of the current object.\n   */\n  get close() {\n    return this.current.name;\n  }\n}\n", "import Blueprint from \"../blueprint\";\n\n/**\n * Renders a given component inside a target HTML element.\n *\n * This function clears the inner HTML of the target element and appends a new\n * element created from the provided component blueprint.\n *\n * @param target - The HTML element where the component will be rendered.\n * @param component - The blueprint of the component to be rendered.\n */\nexport default function render(target: HTMLElement, component: Blueprint) {\n  target.innerHTML = \"\";\n  target.appendChild(document.createElement(`${component}`));\n}\n"],
  "mappings": "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",
  "names": ["array", "listeners", "targetSlot", "slot", "value", "callback"]
}
